<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/.ceiba-metodo/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical id="SUBAGENT_STRATEGY">
    üéØ ESTRATEGIA: Un SUBAGENTE especializado por cada tipo de revisi√≥n.
    Cada subagente tiene contexto limpio y foco total en su especialidad.
    El agente principal (t√∫) solo coordina y consolida resultados.
  </critical>

  <critical id="NO_IMPLEMENTATION">
    üö´ ROL: REVIEWER - Solo detectas problemas, NO implementas fixes.
    Si el usuario pide implementar ‚Üí rechaza y sugiere *desarrollar-historia-usuario
  </critical>

  <step n="1" goal="Recopilar informaci√≥n y validar con usuario">
    <critical>üö´ ORQUESTADOR: Solo recopilar NOMBRES de archivos. NO ejecutar diff de contenido. Los subagentes har√°n el diff.</critical>
    
    <ask>¬øQu√© historia de usuario o incidente deseas revisar? (n√∫mero o ruta)</ask>
    
    <action>Determinar tipo de documento (historia si .story.md o incidente si .incident.md o contiene INC-)</action>
    <action>Buscar archivo en {dev_story_location} o {incident_location}</action>
    <action>Leer contenido completo del archivo</action>
    <action>Extraer: Status, ACs, Tasks</action>
    
    <check if="Status no v√°lido para revisi√≥n">
      <action>Verificar Status en: Lista para Revisi√≥n, Ready for Review, Desarrollo Completado, En Revisi√≥n</action>
      <action if="Status no v√°lido">Mostrar error y detener</action>
    </check>
    
    <ask>üìã MODO DE REVISI√ìN

¬øC√≥mo quieres revisar?
1. **LOCAL** - Cambios locales sin commit (staged + unstaged)
2. **COMMIT** - Desde un commit espec√≠fico (ej: abc1234 o main..feature/xyz)

Indica opci√≥n y, si aplica, el commit/rango.</ask>

    <action>Seg√∫n respuesta, definir comandos git:
      - LOCAL: 
        {{cmd_listar}}: "git diff --name-only" (lista archivos modificados)
        {{cmd_diff}}: "git diff" (obtiene contenido de cambios)
      - COMMIT: 
        {{cmd_listar}}: "git diff --name-only {{commit_ref}}"
        {{cmd_diff}}: "git diff {{commit_ref}}"
    </action>
    
    <action>Si LOCAL: obtener rama actual con "git branch --show-current" ‚Üí {{rama_actual}}</action>
    <action>Detectar repositorios en workspace (buscar directorios con .git)</action>
    <action>Para cada repositorio, ejecutar {{cmd_listar}} y recopilar archivos</action>
    
    <ask>üìã VALIDACI√ìN DE ALCANCE

**Modo:** {{modo}} (LOCAL | COMMIT)
**Rama actual:** {{rama_actual}} (si LOCAL)
**Comando para diff:** {{cmd_diff}}
**Repositorios detectados:**
{{lista_repos_con_archivos}}

¬øEs correcta esta informaci√≥n?
- Confirma para continuar
- Indica repos/archivos a agregar o quitar</ask>

    <action>Esperar confirmaci√≥n del usuario</action>
    <action>Guardar: {{modo}}, {{rama_actual}}, {{cmd_diff}}, {{repos_confirmados}} (lista de {repo_path, archivos[]})</action>
    <action>Extraer ACs del documento</action>
  </step>

  <step n="2" goal="Lanzar subagentes especializados">
    <critical>Cada subagente recibe: cmd_diff + repos_confirmados. Subagente identifica qu√© archivos le aplican y obtiene el diff de cada uno.</critical>
    
    <action>Para cada subagente, incluir en prompt:

üö´ RESTRICCI√ìN: Revisa √öNICAMENTE archivos de {{repos_confirmados}}. NO leas otros archivos.

MODO: {{modo}} (LOCAL | COMMIT)
RAMA ACTUAL: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS Y ARCHIVOS A REVISAR:
{{repos_confirmados}} (formato: repo_path ‚Üí [archivos])

TU PROCESO:
1. De {{repos_confirmados}}, identifica qu√© archivos aplican a tu especialidad
2. Para cada archivo aplicable, navega al repo y ejecuta: {{cmd_diff}} -- {{archivo}}
3. Revisa SOLO las l√≠neas cambiadas (+ y -)
4. Retorna JSON con hallazgos (o vac√≠o si no hay problemas)
    </action>

    <!-- SUBAGENTE: FLUJO_METODO_CEIBA -->
    <action>
      runSubagent({
        description: "Revisar FLUJO_METODO_CEIBA",
        prompt: "Eres un AUDITOR DE PROCESO CEIBA.

DOCUMENTO A REVISAR:
{{story_file_content}}

TIPO: {{tipo_documento}} (historia | incidente)

üö´ NO VALIDAR: Estado de tareas manuales (ej: 'Revisi√≥n de pares', 'QA Manual'). 
Tu labor es SOLO revisar que el documento tenga las secciones requeridas, NO verificar completitud de tareas manuales.

SI ES HISTORIA:
‚Ä¢ Secci√≥n 'An√°lisis Arquitect√≥nico' presente y completada
‚Ä¢ Secci√≥n 'Refinamiento T√©cnico' o 'Tareas de Implementaci√≥n' presente
‚Ä¢ Secci√≥n 'Estimaci√≥n' con valores de complejidad
‚Ä¢ Secci√≥n 'Dev Agent Record' o evidencia de desarrollo completado

SI ES INCIDENTE:
‚Ä¢ Secci√≥n 'Recepci√≥n del Error' (PO) - Status: Triaged
‚Ä¢ Secci√≥n 'Diagn√≥stico' (Architect) - Root Cause Analysis completado
‚Ä¢ Secci√≥n 'Refinamiento T√©cnico' o 'Tareas de Implementaci√≥n' presente
‚Ä¢ Secci√≥n 'Dev Agent Record' o evidencia de desarrollo completado

BLOQUEO: Falta CUALQUIER secci√≥n obligatoria (NO tareas manuales pendientes).

RESPONDE SOLO con JSON:
{\"tipo\": \"FLUJO_METODO_CEIBA\", \"hallazgos\": [{\"archivo\": \"documento\", \"linea\": 0, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: IMPLEMENTACION_VS_REQUISITOS -->
    <action if="ac_list no vac√≠o">
      runSubagent({
        description: "Revisar IMPLEMENTACION_VS_REQUISITOS",
        prompt: "Eres un AUDITOR DE REQUISITOS.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

ACCEPTANCE CRITERIA:
{{ac_list}}

TU PROCESO:
1. Identifica archivos de c√≥digo de producci√≥n (excluyendo tests)
2. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
3. Analiza los cambios contra cada AC

POR CADA AC VALIDAR:
‚Ä¢ Funcionalidad correcta seg√∫n descripci√≥n del AC
‚Ä¢ Manejo de errores y casos borde
‚Ä¢ Validaciones necesarias implementadas

RESPONDE SOLO con JSON:
{\"tipo\": \"IMPLEMENTACION_VS_REQUISITOS\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"AC #N: ...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: BACKEND -->
    <action>
      runSubagent({
        description: "Revisar BACKEND",
        prompt: "Eres un ARQUITECTO BACKEND.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de c√≥digo backend (excluyendo tests)
2. Si no hay archivos backend, retorna hallazgos vac√≠o
3. Para cada archivo backend, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Revisa SOLO los cambios (l√≠neas + y -)

CRITERIOS (revisar SOLO estos):
‚Ä¢ Problemas de arquitectura que afectan mantenibilidad o estabilidad
‚Ä¢ Manejo de errores (try/catch apropiados, excepciones tipadas, logging)
‚Ä¢ Implementaciones que NO respetan la arquitectura del proyecto
‚Ä¢ Integraciones sin tolerancia a fallos (timeouts, reintentos, circuit breaker)

NO REVISAR: compilaci√≥n, rendimiento, seguridad, archivos que no te aplican.

RESPONDE SOLO con JSON:
{\"tipo\": \"BACKEND\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: SEGURIDAD (BOLA) -->
    <action>
      runSubagent({
        description: "Revisar SEGURIDAD",
        prompt: "Eres un AUDITOR DE SEGURIDAD especializado en BOLA (Broken Object Level Authorization).

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de c√≥digo backend y configuraci√≥n
2. Si no hay archivos aplicables, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Analiza SOLO los cambios

SUPERFICIES A AUDITAR: REST, GraphQL, SOAP, gRPC, WebSocket, colas/eventos, jobs, archivos/URLs prefirmadas, buscadores/reportes, repositorios/ORM.

PROCESO DE AUDITOR√çA:
1. Verificar autorizaci√≥n a nivel de recurso
2. Seguir cadena controller ‚Üí service ‚Üí repository
3. Buscar validaciones de ownership
4. Clasificar: SEGURO (tiene validaci√≥n) / VULNERABLE (no tiene)

VULNERABLE = Usuario puede acceder/modificar recursos que NO le pertenecen.

RESPONDE SOLO con JSON:
{\"tipo\": \"SEGURIDAD\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: PENTESTING -->
    <action>
      runSubagent({
        description: "Revisar PENTESTING",
        prompt: "Eres un EXPERTO EN ETHICAL HACKING Y PENTESTING.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de c√≥digo fuente
2. Si no hay archivos de c√≥digo, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Busca vulnerabilidades SOLO en los cambios

VULNERABILIDADES A BUSCAR (OWASP Top 10):
‚Ä¢ Inyecci√≥n (SQL, NoSQL, LDAP, OS Command, HTML)
‚Ä¢ Falta de sanitizaci√≥n de entrada
‚Ä¢ Falta de rate limiting en endpoints sensibles
‚Ä¢ Autenticaci√≥n rota (tokens d√©biles, sesiones sin expirar)
‚Ä¢ Exposici√≥n de datos sensibles (logs, respuestas de error, headers)
‚Ä¢ XXE, Deserializaci√≥n insegura, SSRF
‚Ä¢ Security misconfiguration (CORS, headers)

NO REVISAR: BOLA/IDOR (cubierto por SEGURIDAD).

RESPONDE SOLO con JSON:
{\"tipo\": \"PENTESTING\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: CRIPTOGRAFIA_POSCUANTICA -->
    <action>
      runSubagent({
        description: "Revisar CRIPTOGRAFIA_POSCUANTICA",
        prompt: "Eres un EXPERTO EN SEGURIDAD CRIPTOGR√ÅFICA POSCU√ÅNTICA.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de c√≥digo backend y configuraci√≥n
2. Si no hay archivos aplicables, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Busca uso de criptograf√≠a SOLO en los cambios

ALGORITMOS VULNERABLES A COMPUTACI√ìN CU√ÅNTICA:
‚Ä¢ RSA (cualquier tama√±o de clave)
‚Ä¢ ECDSA, ECDH (curvas el√≠pticas)
‚Ä¢ DSA, DH (Diffie-Hellman cl√°sico)
‚Ä¢ MD5, SHA-1 (ya obsoletos)

BUSCAR en cambios:
‚Ä¢ Uso de algoritmos vulnerables en cifrado, firmas, intercambio de claves
‚Ä¢ Configuraciones TLS/SSL con suites no resistentes a cu√°ntica
‚Ä¢ Certificados con algoritmos vulnerables

RECOMENDAR migraci√≥n a: CRYSTALS-Kyber, CRYSTALS-Dilithium, SPHINCS+, esquemas h√≠bridos.

RESPONDE SOLO con JSON:
{\"tipo\": \"CRIPTOGRAFIA_POSCUANTICA\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: FRONTEND -->
    <action>
      runSubagent({
        description: "Revisar FRONTEND",
        prompt: "Eres un ARQUITECTO FRONTEND.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de c√≥digo frontend (excluyendo tests)
2. Si no hay archivos frontend, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Revisa SOLO los cambios

CRITERIOS:
‚Ä¢ Problemas de arquitectura que afectan mantenibilidad
‚Ä¢ Problemas que afectan estabilidad
‚Ä¢ Manejo de errores inadecuado o inexistente
‚Ä¢ Implementaciones que NO respetan la arquitectura del proyecto

NO REVISAR: compilaci√≥n, rendimiento, seguridad.

RESPONDE SOLO con JSON:
{\"tipo\": \"FRONTEND\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: TESTS INTEGRACI√ìN -->
    <action>
      runSubagent({
        description: "Revisar TESTS_INTEGRACION",
        prompt: "Eres un ARQUITECTO DE CALIDAD enfocado en pruebas de integraci√≥n.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de test de integraci√≥n
2. Si no hay archivos de integraci√≥n, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Revisa SOLO los cambios

CRITERIOS:
1. Patr√≥n Arrange-Act-Assert claramente definido
2. Test Data Builder para crear objetos (no constructores directos)
3. NO mocks de servicios/handlers/repos internos (debe ser integraci√≥n REAL)

EXCEPCIONES V√ÅLIDAS: ApplicationMock (Java), mocks de APIs externas.

RESPONDE SOLO con JSON:
{\"tipo\": \"TESTS_INTEGRACION\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: TESTS UNITARIOS -->
    <action>
      runSubagent({
        description: "Revisar TESTS_UNITARIOS",
        prompt: "Eres un ARQUITECTO DE CALIDAD enfocado en pruebas unitarias.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de test unitario (excluyendo tests de integraci√≥n)
2. Si no hay archivos de test unitario, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Revisa SOLO los cambios

CRITERIOS:
1. Patr√≥n Arrange-Act-Assert claramente definido
2. Test Data Builder para crear objetos
3. Uso correcto de mocks: verify() en Assert

RESPONDE SOLO con JSON:
{\"tipo\": \"TESTS_UNITARIOS\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: CICD -->
    <action>
      runSubagent({
        description: "Revisar CICD",
        prompt: "Eres un ARQUITECTO DEVOPS especializado en pipelines CI/CD.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de pipelines CI/CD
2. Si no hay archivos CI/CD, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Revisa SOLO los cambios

TAREAS OBLIGATORIAS en pipeline:
‚Ä¢ build, test
‚Ä¢ sonar (debe detener si quality gate falla)
‚Ä¢ an√°lisis de vulnerabilidades (dependency track o similar)
‚Ä¢ an√°lisis de licencias
‚Ä¢ an√°lisis de secretos (git leaks o similar)
‚Ä¢ despliegue a producci√≥n Y (pruebas O desarrollo)

BACKEND adicional: pruebas carga, DAST, mutation testing, pruebas arquitectura.
FRONTEND adicional: pruebas funcionales, NO --legacy-peer-deps.

RESPONDE SOLO con JSON:
{\"tipo\": \"CICD\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>

    <!-- SUBAGENTE: FINOPS/GREENOPS -->
    <action>
      runSubagent({
        description: "Revisar FINOPS_GREENOPS",
        prompt: "Eres un EXPERTO EN FINOPS/GREENOPS.

MODO: {{modo}} | RAMA: {{rama_actual}}
COMANDO DIFF: {{cmd_diff}}
REPOSITORIOS: {{repos_confirmados}}

TU PROCESO:
1. Identifica archivos de c√≥digo fuente
2. Si no hay archivos de c√≥digo, retorna hallazgos vac√≠o
3. Para cada archivo, ejecuta: {{cmd_diff}} -- {{archivo}}
4. Busca problemas de eficiencia SOLO en los cambios

BUSCAR problemas CR√çTICOS de costos/eficiencia:
‚Ä¢ Queries N+1, llamadas redundantes
‚Ä¢ Recursos no liberados (conexiones, streams)
‚Ä¢ Algoritmos de complejidad alta evitable
‚Ä¢ Cacheo ausente donde beneficiar√≠a
‚Ä¢ Llamadas s√≠ncronas que podr√≠an ser async/batch
‚Ä¢ Procesamiento redundante
‚Ä¢ Uso ineficiente de memoria

Solo reportar problemas CR√çTICOS con impacto medible.

RESPONDE SOLO con JSON:
{\"tipo\": \"FINOPS_GREENOPS\", \"hallazgos\": [{\"archivo\": \"...\", \"linea\": N, \"severidad\": \"ALTA|MEDIA|BAJA\", \"problema\": \"...\", \"sugerencia\": \"...\"}]}"
      })
    </action>
  </step>

  <step n="3" goal="Consolidar resultados de subagentes">
    <action>Parsear JSON de cada subagente y unificar todos los hallazgos</action>
    <action>Eliminar resultados duplicados (mismo archivo + misma l√≠nea + problema similar)</action>
    <action>Contar por severidad: alta_count, media_count, baja_count</action>
  </step>

  <step n="4" goal="Validar con usuario">
    <action>Mostrar tabla consolidada de hallazgos al usuario</action>
    <ask>Revisa los hallazgos:
- Si todos aplican ‚Üí confirma para persistir
- Si alguno NO_APLICA ‚Üí ind√≠came cu√°l y el motivo</ask>
    <action>Esperar respuesta del usuario antes de continuar</action>
    <action>Para cada hallazgo marcado NO_APLICA: actualizar Estado y agregar motivo en columna Sugerencia</action>
    <action>Recalcular conteos excluyendo NO_APLICA</action>
  </step>

  <step n="5" goal="Decidir">
    <action>Decisi√≥n:
      - BLOQUEADO: alta_count > 3 OR vulnerabilidad cr√≠tica de seguridad
      - CAMBIOS SOLICITADOS: alta_count >= 1 OR media_count > 5
      - APROBADO CON OBSERVACIONES: alta_count == 0 AND media_count entre 1-5
      - APROBADO: alta_count == 0 AND media_count == 0
    </action>
    <action>Mostrar resumen con decisi√≥n y lista consolidada de hallazgos</action>
  </step>

  <step n="6" goal="Persistir y siguiente paso">
    <action>Usar template: {installed_path}/template.md como gu√≠a para el formato de salida</action>
    <action>Appendar al archivo de historia la secci√≥n "## Revisi√≥n de C√≥digo (Peer Review)" con:
      - Revisor, Fecha, Decisi√≥n
      - Tabla resumen (ALTA, MEDIA, BAJA counts)
      - Una secci√≥n "#### TIPO" por cada tipo de revisi√≥n que tenga hallazgos
      - Tabla de hallazgos por tipo: Archivo | L√≠nea | Severidad | Estado | Problema | Sugerencia
    </action>
    <action>Omitir secciones de tipos sin hallazgos (no incluir tablas vac√≠as)</action>
    <action>Actualizar Status: Aprobado‚Üí"Aprobada", Aprobado con Obs‚Üí"Aprobada con Observaciones", Cambios Sol‚Üí"Cambios Solicitados", Bloqueado‚Üí"Bloqueada"</action>
    
    <output if="decisi√≥n != 'APROBADO'">
üìã Para corregir los hallazgos:
1. Activa el agente Developer con *help
2. Ejecuta *desarrollar-historia-usuario
    </output>
  </step>

</workflow>
