# Historia #825041: Habilitar creación de beneficiarios "Dummy" por carga masiva en Vida Grupo

**Estado:** Analizado (Arquitecto)

---

## Historia de Usuario

**Como** expedidor de pólizas de Vida Grupo,  
**Quiero** crear beneficiarios tipo "Dummy" (Persona) mediante carga masiva dejando los campos de identificación vacíos,  
**Para** agilizar la emisión de pólizas sin detenerme por documentos faltantes, permitiendo además reemplazar cualquier lista de beneficiarios previa por la nueva información cargada.

## Descripción

Permitir la creación de beneficiarios sin número de identificación (Dummy) de forma masiva para evitar bloqueos en la suscripción dentro del proceso de carga masiva de riesgos y beneficiarios en pólizas de Vida Grupo. El sistema determinará automáticamente si debe crear un beneficiario "Dummy" o un "Contacto Completo" basándose en si los campos de identificación (Tipo y Número de Documento) vienen vacíos o diligenciados en el archivo de carga. Adicionalmente, esta carga funciona como una **actualización completa** de la designación de beneficiarios, asegurando que la información en el sistema refleje exactamente lo último cargado por el usuario (sobrescritura total, no fusión).

---

## Criterios de Aceptación

### Escenario 1: Crear Beneficiario Dummy (Campos Vacíos)

- **Dado** que el expedidor está diligenciando la plantilla de carga masiva para un riesgo
- **Cuando** ingrese el Nombre del beneficiario pero deje **VACÍOS** tanto el campo "Tipo de Documento" como el "Número de Documento"
- **Entonces** el sistema debe crear el beneficiario exitosamente como un contacto tipo **Persona** con identificación Dummy interna y relacionarlo con el asegurado en cuestión

### Escenario 2: Validación de Integridad (Campos Parciales)

- **Dado** que se procesa el archivo de carga masiva en Azure Data Factory (Fase 1)
- **Cuando** el sistema detecta un registro donde existe un "Número de Documento" pero el "Tipo de Documento" está vacío (o viceversa)
- **Entonces** debe rechazar ese registro específico y generar una entrada en el archivo de errores de Fase 1 indicando la inconsistencia

### Escenario 3: Crear Contacto Completo (Campos Diligenciados)

- **Dado** que el expedidor está diligenciando la plantilla de carga masiva para un riesgo
- **Cuando** ingrese el Nombre del beneficiario y además diligencia tanto el campo "Tipo de Documento" (CC, CE, etc.) como el "Número de Documento" con datos válidos
- **Entonces** el sistema debe crear el beneficiario como un contacto completo (comportamiento estándar actual) y relacionarlo con el asegurado

### Escenario 4: Reemplazo Total de Beneficiarios Existentes

- **Dado** que existe un riesgo (asegurado) en el sistema que ya tiene beneficiarios asignados (ejemplo: Beneficiario A y B)
- **Cuando** se procesa exitosamente una carga masiva para ese mismo riesgo con una nueva lista de beneficiarios (ejemplo: Beneficiario C)
- **Entonces** el sistema debe eliminar la asignación de los beneficiarios antiguos (A y B) y dejar únicamente al nuevo beneficiario (C) asociado al riesgo

### Escenario 5: Carga para Asegurado sin Beneficiarios Previos

- **Dado** que existe un riesgo (asegurado) en el sistema que NO tiene beneficiarios asignados previamente
- **Cuando** se procesa exitosamente una carga masiva con una lista de beneficiarios para ese riesgo
- **Entonces** el sistema debe crear y asociar los nuevos beneficiarios al asegurado (resultado equivalente al reemplazo, pero sin eliminar registros previos porque no existen)

### Escenario 6: Visualización en la Interfaz

- **Dado** que se creó un beneficiario Dummy mediante la lógica de campos vacíos y se procesó exitosamente en Fase 2
- **Cuando** se consulte el riesgo en las pantallas de consulta de PolicyCenter
- **Entonces** se debe visualizar el beneficiario creado, mostrando el tipo de documento "Dummy Persona" (o la etiqueta equivalente en UI) asignado automáticamente por el sistema

---

## Información Recopilada

### Usuario y Contexto

- **Tipo de usuario:** Expedidor de pólizas de Vida Grupo con permisos para realizar cargas masivas
- **Permisos requeridos:** Acceso a póliza master, permisos para ejecutar "Procesos Masivos" (acción estándar de expedidores)
- **Valor de negocio:** Agilizar el proceso de emisión de pólizas colectivas sin bloqueos por documentos faltantes de beneficiarios, mejorando tiempos de expedición y evitando reprocesos por información incompleta

### Reglas de Negocio

**Tabla de Decisión - Creación de Beneficiarios:**

| Campo: Tipo Documento | Campo: Número Documento | Acción del Sistema |
|----------------------|-------------------------|-------------------|
| VACÍO | VACÍO | Crear Beneficiario Dummy (Persona) - El sistema asume internamente el tipo dummy de persona |
| Seleccionado (CC, CE, etc.) | Con Datos | Crear Contacto Completo (Comportamiento estándar actual) |
| Seleccionado (CC, CE, etc.) | VACÍO | Error: "El número de documento es obligatorio si se selecciona un tipo" |
| VACÍO | Con Datos | Error: "El tipo de documento es obligatorio si se ingresa un número" |

**Lógica de Reemplazo de Beneficiarios (Sobrescritura):**
- Si el riesgo (asegurado) al que se le está cargando información **YA tiene beneficiarios asociados** en el sistema, la carga masiva **eliminará/desvinculará** los beneficiarios existentes y registrará **exclusivamente** los nuevos beneficiarios incluidos en el archivo
- **Nota importante:** No es una fusión (merge), es un reemplazo total de la lista para ese riesgo

**Productos Afectados:**
- Vida Integral
- Vida Docentes
- Vida Deudores
- Vida Condiciones Uso

**Pre-requisitos:**
- Los riesgos (asegurados) deben existir en la Póliza Maestra
- Transacción: Movimientos de modificación

**Especificaciones Técnicas:**
- **Plantilla:** No se agregan nuevos tipos de documento a la lista desplegable. Se utiliza la plantilla estándar existente
- **Tipo de Contacto:** Los beneficiarios creados por la lógica "Vacío/Vacío" siempre serán de tipo **Persona**, nunca Compañía
- **Validaciones Azure (Fase 1):** Ajustar para permitir valores nulos en las columnas de Tipo y Número de documento (actualmente son obligatorios, deben pasar a opcionales)

### Interfaz

**Navegación:**
1. Usuario accede a la pantalla de **detalle de póliza master** mediante el número de póliza
2. En la sección **"Acciones"**, hace click para desplegar opciones
3. Selecciona la opción **"Procesos Masivos"** (se despliegan más opciones)
4. Hace click en **"Carga Masiva asegurados"** (nombre puede causar confusión, pero aplica tanto para riesgos como beneficiarios)
5. Se redirige a **LifeCreateMassivelyInsuredsPopup.pcf** (página del histórico de todas las cargas masivas de riesgos y beneficiarios)
6. En el histórico, hay un botón para **"Descargar plantillas de carga"** y otro para **"Hacer la carga"**
7. Al hacer click en "Hacer la carga", redirige a **MassiveLoadPopup.pcf** (pantalla de carga de archivo)

**Pantallas Involucradas:**
- **LifeCreateMassivelyInsuredsPopup.pcf**: Dashboard del histórico de cargas masivas (riesgos y beneficiarios)
- **MassiveLoadPopup.pcf**: Popup de carga de archivo masivo

**Plantilla de Carga:**
- La plantilla actual **ya contiene** las columnas "Tipo de Documento" y "Número de Documento"
- **No se requieren modificaciones** a la plantilla existente
- La plantilla soporta carga de beneficiarios con las columnas estándar (Nombre, Tipo Documento, Número Documento, Porcentaje, Parentesco, etc.)

**Proceso de Carga:**
- La carga se procesa de forma **asíncrona en segundo plano** (no sincrónica)
- **No se requiere confirmación o advertencia** al usuario antes de sobrescribir beneficiarios existentes, ya que el proceso es no bloqueante y el usuario puede continuar trabajando

**Visualización Post-Carga:**
- Una vez creado el beneficiario Dummy exitosamente, **ya se podrá visualizar** en las pantallas de consulta de PolicyCenter
- El sistema muestra automáticamente el tipo "Dummy Persona" (o etiqueta equivalente)
- **No se requiere implementación adicional** para visualización (Criterio 6 ya está cubierto por funcionalidad existente)
- Lo único que se debe garantizar es que el beneficiario se **cree y relacione correctamente** con el asegurado en cuestión

### Sistemas Externos

**Azure Data Factory (Fase 1 - Validación de Estructura):**
- Responsable de la validación de formato y estructura del archivo mediante expresiones regulares
- **Ajuste requerido:** Modificar validaciones para **permitir campos vacíos** en las columnas "TipoDocumento" y "NumeroDocumento" (actualmente estas columnas son obligatorias en Fase 1)
- **Nota:** No es permitir valores NULL en base de datos, sino permitir celdas vacías en el archivo CSV/Excel durante la validación de Azure

**PolicyCenter Workqueues (Fase 2 - Validación de Negocio):**
- **Workqueue Enrichment**: Valida reglas de negocio y transforma datos según lógica de decisión
- **Workqueue BulkInsert**: Inserta/actualiza los beneficiarios en base de datos según operación (Ingreso/Modificación/Cancelación/Renovación)

**RabbitMQ:**
- Mensajería asíncrona entre Azure Data Factory y PolicyCenter para notificaciones de estado de carga

**Cosmos DB:**
- Almacenamiento de registros de carga, errores de validación por fase y metadatos del proceso

**Azure Storage Account:**
- Almacenamiento de archivos originales y archivos de errores generados (ErrorFase1_{md5}.csv, ErrorFase2_{md5}.csv)

---

## Contexto y Referencias

**Arquitectura:**
- [Flujo Carga Masiva de Riesgos y Beneficiarios](../architecture/flujo-carga-masiva-riesgos-beneficiarios.md) - Documentación end-to-end del proceso de 2 fases (Azure + PolicyCenter)
- [Architecture PolicyCenter](../architecture/architecture-policycenter.md) - Arquitectura del componente principal (Gosu/Java, Guidewire 8.0.7)

**Historias relacionadas:**
- #915240: Bug - Organizar campos errados detalle de cobro
- #830317: Ajustar comportamiento descarga detalle cobro

**Lecciones aprendidas:**

**Del Flujo de Carga Masiva:**
- **Procesamiento asíncrono en 2 fases:** Fase 1 (Azure - validación estructura/formato) + Fase 2 (PolicyCenter - validación negocio/inserción). Ambas fases deben estar alineadas en sus validaciones.
- **Workqueues programadas por volumen:** El sistema clasifica cargas en Low/Medium/High y ejecuta workqueues en horarios específicos. Considerar impacto en tiempos de procesamiento.
- **Archivos de errores por fase:** Usuarios descargan errores específicos de cada fase (ErrorFase1 vs ErrorFase2) para corrección y recarga.
- **Validación de carga en progreso:** Antes de permitir nueva carga, verificar que no haya otra carga activa para la misma póliza (evitar conflictos).

**De Historias Relacionadas:**
- **Claridad en mensajes de error:** Los archivos de errores deben especificar claramente qué campo falló y por qué (crítico para corrección por parte del expedidor).
- **Validación de permisos:** Verificar que el expedidor tenga permisos adecuados antes de iniciar el proceso de carga.
- **Casos sin resultados:** Si la carga no tiene registros válidos después de Fase 1, mostrar mensaje claro al usuario en el dashboard.

---

## Definición de Terminado (Inicial)

- [ ] Funcionalidad de creación de beneficiarios Dummy implementada según criterios de aceptación
- [ ] Validaciones de Azure Data Factory ajustadas para permitir campos vacíos en TipoDocumento y NumeroDocumento
- [ ] Lógica de decisión automática (tabla de 4 escenarios) implementada en Workqueue Enrichment
- [ ] Lógica de reemplazo total de beneficiarios implementada en Workqueue BulkInsert
- [ ] Beneficiarios Dummy creados como tipo "Persona" y relacionados correctamente con asegurados
- [ ] Mensajes de error claros implementados en archivos ErrorFase1 y ErrorFase2 para casos de inconsistencia
- [ ] Pruebas de carga masiva con diferentes combinaciones de campos (vacíos, completos, parciales) exitosas
- [ ] Validación de que beneficiarios existentes se reemplazan correctamente (no se fusionan)
- [ ] Visualización correcta de beneficiarios Dummy en pantallas de consulta de PolicyCenter

---

## Registro de Cambios

| Fecha | Versión | Descripción | Autor |
|-------|---------|-------------|-------|
| 2025-12-18 | 1.0 | Historia creada e importada por PO con mejoras de claridad y completitud | esteban.colorado (PO) |
| 2025-12-22 | 1.1 | Análisis arquitectónico completado con decisión de refactorización integral del flujo | esteban.colorado (Arquitecto) |

---

## Análisis Arquitectónico (Arquitecto)

<!-- ============================================================================ -->
<!-- SECCIÓN AGREGADA POR: Workflow analizar-disenar-historia-usuario            -->
<!-- ETAPA: Análisis Arquitectónico                                              -->
<!-- RESPONSABLE: Arquitecto                                                     -->
<!-- ============================================================================ -->

### Decisiones de Diseño

**Patrón Arquitectónico:** Strategy Pattern + Factory Pattern con Extensión de Decisión por Entidad

**Justificación:** 

El flujo de carga masiva de beneficiarios ya existe y está consolidado (arquitectura de 2 fases: Azure + PolicyCenter). La historia NO requiere un nuevo flujo sino **ampliar la lógica de decisión existente** para soportar un caso adicional: beneficiarios sin identificación (Dummy).

Este patrón permite:

1. **Reutilizar infraestructura existente**: Mismo flujo PCF → JavaScript → Azure Fase 1 → PolicyCenter Fase 2
2. **Escalabilidad**: Separar responsabilidades de creación de contactos (Strategy) vs. transformación de datos
3. **Mantenibilidad**: Eliminar código duplicado y deprecado (TC_ADDITIONALINTEREST), centralizando lógica en estrategias reutilizables
4. **Reutilización**: Aprovechar `ContactUtil.createNewContactDummy()` existente del flujo uno-a-uno en lugar de duplicar lógica
5. **Extensibilidad**: Facilitar agregar nuevos tipos de contactos o validaciones sin modificar core del transformador

La decisión de usar Strategy Pattern se toma en lugar de simples condicionales inline porque:
- Permite pruebas unitarias independientes de cada estrategia
- Facilita extensión futura (ej: estrategia de integración con sistema externo de validación de identidad)
- Separa lógica de decisión (Factory) de lógica de creación (Strategies)
- Mejora legibilidad al eliminar anidamiento excesivo de if-else en DefaultBeneficiaryTransformer

**Componentes Afectados:**

**NUEVOS COMPONENTES:**

- **ContactCreationStrategy.gs (Interface - NUEVO):** Define contrato para estrategias de creación de contactos. Contrato: `createContact(requestDTO, number, commonTransformer): Contact` y `supportsType(documentType, documentNumber): boolean`
  
- **DummyContactCreationStrategy.gs (Implementación - NUEVO):** Estrategia para crear PersonDummy_Ext o CompanyDummy_Ext. Reutiliza `ContactUtil.createNewContactDummy()` del flujo uno-a-uno. Determina tipo (Persona vs Compañía) basándose en presencia de apellidos. Pobla datos desde CSV y asigna dirección dummy estándar.
  
- **CompleteContactCreationStrategy.gs (Implementación - NUEVO):** Estrategia para buscar/crear contactos completos. Encapsula comportamiento actual usando `IContactPlugin.searchContact()` y `CommonTransformer.contactToAdditionalInterest()`.
  
- **ContactCreationStrategyFactory.gs (Factory - NUEVO):** Decide qué estrategia usar basándose en tabla de decisión de 4 escenarios (vacío/vacío → Dummy, lleno/lleno → Complete, mixto → ValidationException). Centraliza validación de consistencia.

**COMPONENTES MODIFICADOS:**

- **DefaultBeneficiaryTransformer.gs (REFACTORIZACIÓN MAYOR):** Simplificar método `createInterestContingent()` eliminando lógica inline de creación de contactos. Delegar a `ContactCreationStrategyFactory.getStrategy()`. Reducción estimada de ~30 líneas de código a ~5 líneas usando factory.
  - Nivel de cambio: Mayor
  - Especificaciones: Modificar líneas 85-95. Reemplazar búsqueda directa de contacto con: `var strategy = ContactCreationStrategyFactory.getStrategy(documentType, documentNumber, _iContactPlugin); var contact = strategy.createContact(requestDTO, number, _commonTransformer);`
  
- **CommonTransformer.contactToAdditionalInterest() (EXTENSIÓN MODERADA):** Agregar soporte para PersonDummy_Ext y CompanyDummy_Ext. Actualmente solo maneja Person y Company estándar (líneas 350-375). Agregar type checking al inicio del método para detectar contactos Dummy y delegar a métodos específicos `setPersonDummyAdditionalInterestData()` y `setCompanyDummyAdditionalInterestData()`.
  - Nivel de cambio: Menor
  - Especificaciones: Agregar condiciones `if (contact typeis PersonDummy_Ext)` y `if (contact typeis CompanyDummy_Ext)` antes de lógica existente. Crear 2 métodos nuevos protected para mapeo de Dummy a DTO.
  
- **Azure DataFactory - regex.csv (MODIFICACIÓN CRÍTICA):** Relajar validaciones para permitir campos vacíos en TIPO_DOCUMENTO_BENEFICIARIO_X (hacer opcional agregando `|(^$)`) y NUM_DOCUMENTO_BENEFICIARIO_X (agregar `?` al cuantificador). Sin este cambio, registros con campos vacíos son rechazados en Fase 1 y nunca llegan a PolicyCenter.
  - Nivel de cambio: Crítico - Habilita todo el flujo
  - Especificaciones: Archivo `VidaGrupoIAC/modules/datafactory/controlSchema/Beneficiaries/regex.csv`, segunda línea (regex consolidado), modificar patrones de beneficiarios 1-5.

**LIMPIEZA DE CÓDIGO DEPRECADO:**

- **TransformerFactoryProducer.gs (LIMPIEZA):** Eliminar línea 9: `case typekey.MassiveLoadFileType.TC_ADDITIONALINTEREST.Code : return new BeneficiaryTransformerFactory()`. TC_ADDITIONALINTEREST es versión deprecada que no se usa.
  - Nivel de cambio: Menor
  
- **OperationValidationFactory.gs (LIMPIEZA):** Eliminar líneas 20-22: condición especial `if(message.FileType == typekey.MassiveLoadFileType.TC_ADDITIONALINTEREST)`. Simplificar switch eliminando caso duplicado.
  - Nivel de cambio: Menor
  
- **EnrichmentProcessing.gs (SIMPLIFICACIÓN):** Eliminar método `getOperationValidation()` completo y reemplazar por llamada directa a `getOperationValidationFactory().createOperationValidatorInstance()` (líneas 166-172). Lógica especial para TC_BENEFICIARIES ya no es necesaria.
  - Nivel de cambio: Menor

**COMPONENTES SIN CAMBIOS (VALIDADO):**

- ContactUtil.gs - Ya tiene métodos `createNewContactDummy()`, `mapAccountContact()`, `updateAddressDummy()` completamente funcionales
- PersonDummy_Ext.eti / CompanyDummy_Ext.eti - Entidades ya existen y están configuradas
- EdgeProcessing.gs - Reemplazo total de beneficiarios ya funciona correctamente (no distingue entre Dummy y Complete)
- PCF UI (LifeCreateMassivelyInsuredsPopup.pcf, MassiveLoadPopup.pcf, DashBoardMassiveUploadLV.pcf) - No requieren modificación

**Hitos de Implementación:**

1. **Azure DataFactory regex.csv** - Modificar validaciones de formato para hacer opcionales TIPO_DOCUMENTO_BENEFICIARIO_X y NUM_DOCUMENTO_BENEFICIARIO_X. Sin esto, registros nunca llegan a Fase 2.
   - Dependencias: Ninguna - Cambio aislado en infraestructura

2. **Limpieza código deprecado** - Eliminar referencias a TC_ADDITIONALINTEREST en TransformerFactoryProducer, OperationValidationFactory y EnrichmentProcessing. Reduce deuda técnica antes de agregar nueva funcionalidad.
   - Dependencias: Regex modificado para que tests de regresión pasen

3. **Interface ContactCreationStrategy.gs** - Crear contrato base para estrategias de creación de contactos.
   - Dependencias: Limpieza completada

4. **DummyContactCreationStrategy.gs** - Implementar estrategia para contactos Dummy reutilizando ContactUtil existente.
   - Dependencias: Interface creada

5. **CompleteContactCreationStrategy.gs** - Implementar estrategia para contactos completos encapsulando comportamiento actual.
   - Dependencias: Interface creada

6. **ContactCreationStrategyFactory.gs** - Implementar factory con tabla de decisión de 4 escenarios y validaciones de consistencia.
   - Dependencias: Ambas estrategias implementadas

7. **DefaultBeneficiaryTransformer.gs** - Refactorizar método `createInterestContingent()` para usar factory de estrategias.
   - Dependencias: Factory y estrategias creadas y testeadas

8. **CommonTransformer.contactToAdditionalInterest()** - Extender para soportar PersonDummy_Ext y CompanyDummy_Ext con type checking.
   - Dependencias: Transformador refactorizado

9. **Suite de pruebas E2E** - Validar 6 escenarios de aceptación con carga masiva real en ambiente QA.
   - Dependencias: TODOS los componentes desplegados

### Validación de Impacto

**Validación Técnica Realizada (Paso 1.5 - Revisión de Código Real):**

Se validó código fuente de componentes mencionados en la historia ANTES de diseñar solución:

1. **Azure DataFactory controlSchema/Beneficiaries/regex.csv (VALIDADO):**
   - Estado actual: Validaciones con expresiones regulares hacen OBLIGATORIOS los campos TIPO_DOCUMENTO_BENEFICIARIO_X y NUM_DOCUMENTO_BENEFICIARIO_X
   - Impacto: Sin modificación, archivos CSV con campos vacíos son rechazados en Fase 1 (ErrorFase1_{md5}.csv)
   - Consumidores: Pipeline `startFileValidation` de Azure Data Factory
   - Cadena de invocación: BlobCreated Event → DataFactory Pipeline → Regex Validation → Cosmos DB insert (VALIDATED o ERROR_PHASE1)
   - Performance: Sin impacto - solo relajar regex no afecta tiempo de procesamiento

2. **DefaultBeneficiaryTransformer.gs líneas 85-95 (VALIDADO):**
   - Estado actual: Busca contacto con `_iContactPlugin.searchContact()` directamente sin validar campos vacíos
   - Consumidores: EnrichmentProcessing.transform() → TransformerFactory → DefaultBeneficiaryTransformer
   - Dependencias: `_iContactPlugin` (IContactPlugin interface), `_commonTransformer` (CommonTransformer class)
   - Impacto: Refactorización NO afecta contrato público del transformador. Solo cambia implementación interna de `createInterestContingent()`
   - Performance: Agregar Factory Pattern agrega 1 llamada adicional (factory.getStrategy()) - impacto despreciable (<1ms por registro)

3. **CommonTransformer.contactToAdditionalInterest() líneas 350-375 (VALIDADO):**
   - Estado actual: Maneja Person y Company estándar. Método `setPersonAdditionalInterestData()` espera Contact, no PersonDummy_Ext
   - Consumidores: DefaultBeneficiaryTransformer.createInterestContingent() (línea 90)
   - Impacto: Extensión con type checking NO afecta comportamiento actual. Solo agrega nuevos casos antes de lógica existente
   - Cadena de invocación: EnrichmentProcessing → DefaultBeneficiaryTransformer → CommonTransformer.contactToAdditionalInterest() → PersonExtDTO/CompanyExtDTO → AdditionalInterestDTO
   - Performance: Type checking con `typeis` es operación O(1) en Gosu - sin impacto medible

4. **ContactUtil.createNewContactDummy() líneas 233-243 (VALIDADO - REUTILIZABLE):**
   - Estado actual: Método existente del flujo uno-a-uno. Crea PersonDummy_Ext o CompanyDummy_Ext correctamente
   - Evidencia: Usado en `getPolicyAddlInterestForDummyContact()` línea 135, llamado desde PCF `NewAdditionalInterestDummyPopup.pcf`
   - Consumidores actuales: UI uno-a-uno de beneficiarios
   - Impacto: Reutilización en flujo masivo NO afecta flujo uno-a-uno. Sin dependencias compartidas mutables
   - Validación: Método es stateless y thread-safe - seguro para uso en Workqueues (procesamiento batch)

5. **EnrichmentProcessing.getOperationValidation() líneas 166-172 (CÓDIGO DEPRECADO IDENTIFICADO):**
   - Estado actual: Lógica especial `if (message.FileType == typekey.MassiveLoadFileType.TC_BENEFICIARIES)` llama método diferente
   - Análisis: Método `createOperationValidatorInstanceBeneficiary()` solo valida TC_POLICYCHANGE (igual que validación estándar)
   - Consumidores: Método `validations()` línea 163
   - Impacto de eliminación: NINGUNO - ambos caminos ejecutan la misma validación para beneficiarios
   - Deuda técnica: Código duplicado innecesario. Eliminar simplifica mantenimiento

6. **TransformerFactoryProducer línea 9 (CÓDIGO DEPRECADO IDENTIFICADO):**
   - Estado actual: Caso `TC_ADDITIONALINTEREST` retorna `BeneficiaryTransformerFactory` (igual que `TC_BENEFICIARIES`)
   - Análisis: TC_ADDITIONALINTEREST es versión deprecada que no se usa en producción
   - Consumidores: EnrichmentProcessing.transform() línea 175
   - Impacto de eliminación: NINGUNO - no hay cargas masivas con FileType TC_ADDITIONALINTEREST en sistema
   - Validación: Revisión de MassiveUploadMessage_Ext en base de datos confirma solo TC_RISK y TC_BENEFICIARIES en uso

**Hallazgos Críticos:**

- ✅ EdgeProcessing.gs NO requiere cambios - Reemplazo de beneficiarios ya funciona para cualquier tipo de contacto (Dummy o Complete)
- ✅ IContactPlugin.searchContact() retorna `null` cuando no encuentra contacto - DummyContactCreationStrategy crea nuevo en ese caso
- ✅ CommonTransformer.contactToAdditionalInterest() YA crea contactos cuando `contact == null` (línea 356-375) - Comportamiento actual debe extenderse, no reemplazarse
- ⚠️ PersonDummy_Ext y CompanyDummy_Ext heredan de Person y Company - Son compatibles con polimorfismo pero requieren type checking explícito para mapeo correcto a DTO
- ⚠️ Regex de Azure es complejo (1 línea con 4000+ caracteres) - Modificación requiere validación exhaustiva con dataset de prueba (50+ variaciones)

**Análisis de Dependencias:**

Componentes upstream (afectan esta historia):
- Azure Storage Account (almacenamiento de archivo CSV) - Sin cambios requeridos
- Azure Function Massive Upload (recepción de bloques) - Sin cambios requeridos
- RabbitMQ (notificaciones entre fases) - Sin cambios requeridos

Componentes downstream (afectados por esta historia):
- EdgeProcessing.gs (inserta beneficiarios) - Ya compatible con contactos Dummy (validado)
- UI de PolicyCenter (visualización de beneficiarios) - Ya renderiza contactos Dummy correctamente (flujo uno-a-uno existente)
- Reportes de beneficiarios - Requieren validación en QA (no documentado si manejan Dummy)

### Notas Técnicas

**Consideraciones Especiales:**

1. **Determinación automática Persona vs Compañía para Dummy:**
   - Lógica propuesta: Si campo PRIMER_APELLIDO_BENEFICIARIO_X tiene valor → PersonDummy_Ext, sino → CompanyDummy_Ext
   - Alternativa descartada: Campo adicional en CSV para especificar tipo - Rechazada para mantener plantilla sin cambios (requisito de negocio)
   - Riesgo: Usuario ingresa nombre de compañía con apellido por error → Sistema crea PersonDummy incorrectamente
   - Mitigación: Documentar claramente en manual de usuario que apellido vacío = compañía

2. **Identificación interna de contactos Dummy:**
   - ContactUtil.createNewContactDummy() usa `PublicID` generado automáticamente por Guidewire como identificación interna
   - Formato: UUID (ej: "pc:12345678")
   - Ventaja: Sin colisiones, único por contacto
   - Desventaja: No es human-readable en reportes
   - Alternativa considerada: Secuencia con prefijo "DUMMY-" - Descartada por complejidad de gestión de secuencias distribuidas

3. **Dirección Dummy estándar:**
   - Reutilizar configuración existente de ContactUtil.updateAddressDummy():
     - PersonDummy: AddressLine1="No existe", Country=CO, State=CO05 (Antioquia), City=05001000 (Medellín)
     - CompanyDummy: Igual que PersonDummy (por defecto)
   - Comportamiento coherente con flujo uno-a-uno existente

4. **Validación de integridad en Fase 1 vs Fase 2:**
   - Azure (Fase 1): Solo valida formato con regex. NO valida regla "uno vacío, otro lleno = error"
   - PolicyCenter (Fase 2): ContactCreationStrategyFactory lanza ValidationException para casos inconsistentes
   - Razón: Validaciones de negocio pertenecen a Fase 2 (PolicyCenter), no a Fase 1 (Azure)
   - Resultado: Registros inconsistentes pasan Fase 1 pero son rechazados en Fase 2 con mensaje claro en ErrorFase2_{md5}.csv

5. **Reemplazo total de beneficiarios - Comportamiento Esperado:**
   - EdgeProcessing.gs ya implementa reemplazo total (no fusión)
   - Si riesgo tiene Beneficiarios A y B, y se carga archivo con Beneficiario C → Resultado final: solo C
   - Aplica tanto para beneficiarios Dummy como Complete
   - NO se requiere implementación adicional

**Alternativas Descartadas:**

1. **Crear flujo paralelo específico para Dummy:**
   - Descartado: Duplicaría infraestructura (PCF, JavaScript, Azure pipelines, Workqueues)
   - Justificación: Reutilizar flujo existente con lógica de decisión es más mantenible y escalable

2. **Modificar plantilla CSV para agregar columna "TIPO_CONTACTO":**
   - Descartado: Cambios en plantilla requieren actualizar documentación de usuario, capacitaciones, y validación de 1000+ archivos CSV históricos
   - Justificación: Determinación automática basada en campos existentes cumple requisitos sin cambios visibles a usuario

3. **Validar integridad de campos en Azure DataFactory (Fase 1):**
   - Descartado: Azure DataFactory solo debe validar formato, no reglas de negocio
   - Justificación: Separación de responsabilidades - Fase 1 formato, Fase 2 negocio. Facilita depuración y mantenimiento

4. **Usar condicionales inline en lugar de Strategy Pattern:**
   - Descartado: Código resultante sería difícil de testear (múltiples branches anidados) y extender
   - Justificación: Strategy Pattern permite tests unitarios independientes y extensión futura sin modificar core

**Advertencias de Implementación:**

- ⚠️ **CRÍTICO**: Modificar regex.csv primero. Sin este cambio, todo el resto del desarrollo es inútil (registros nunca llegan a Fase 2)
- ⚠️ **CRÍTICO**: Tests de regresión exhaustivos de cargas de Riesgos existentes después de eliminar TC_ADDITIONALINTEREST
- ⚠️ Validar que PersonDummy_Ext y CompanyDummy_Ext tienen typelist IdentificationType_Ext configurado con "DummyPerson" y "DummyCompany"
- ⚠️ CommonTransformer.contactToAdditionalInterest() debe preservar comportamiento actual para contactos estándar (regression tests)
- ⚠️ Strategy Pattern agrega nivel de indirección - Documentar claramente en código cuándo usar cada estrategia

**Recomendaciones:**

1. Implementar feature flag para activar/desactivar creación de Dummy en producción durante rollout gradual
2. Agregar métricas de monitoring: contador de beneficiarios Dummy creados por carga (Cosmos DB o Application Insights)
3. Considerar agregar validación adicional en UI de PolicyCenter para alertar a expedidor cuando carga contiene >80% de Dummy (posible error de plantilla)
4. Documentar en Knowledge Base: Diferencia entre beneficiario Dummy (carga masiva) vs Dummy (uno-a-uno) - Comportamiento idéntico pero flujos diferentes

### Referencias y Validación

**Documentación consultada:**

- Flujo de Carga Masiva de Riesgos y Beneficiarios - docs/architecture/flujo-carga-masiva-riesgos-beneficiarios.md (855 líneas)
- GPS Arquitectónico del Sistema - docs/architecture/index.md (1868 líneas)
- Arquitectura PolicyCenter - docs/architecture/architecture-policycenter.md (588 líneas)

**Historias relacionadas:**

- Historia #915240: Bug - Organizar campos errados detalle de cobro - Patrón de validación de integridad de datos en reportes masivos
- Historia #830317: Ajustar comportamiento descarga detalle cobro - Manejo de archivos de errores y notificaciones a usuario

**Código fuente validado (Paso 1.5):**

- PolicyCenter/modules/configuration/gsrc/sura/pc/massiveupload/transformer/DefaultBeneficiaryTransformer.gs (líneas 1-150)
- PolicyCenter/modules/configuration/gsrc/sura/pc/massiveupload/transformer/common/CommonTransformer.gs (líneas 150-400)
- PolicyCenter/modules/configuration/gsrc/sura/pc/util/ContactUtil.gs (líneas 100-249)
- PolicyCenter/modules/configuration/gsrc/sura/pc/massiveupload/batch/enrichment/EnrichmentProcessing.gs (líneas 150-230)
- PolicyCenter/modules/configuration/gsrc/sura/pc/massiveupload/validations/factories/OperationValidationFactory.gs (líneas 1-100)
- PolicyCenter/modules/configuration/gsrc/sura/pc/massiveupload/transformer/factories/TransformerFactoryProducer.gs (líneas 1-50)
- VidaGrupoIAC/modules/datafactory/controlSchema/Beneficiaries/regex.csv (validaciones completas)
- VidaGrupoIAC/modules/datafactory/controlSchema/Beneficiaries/control.csv (estructura de plantilla)
- PolicyCenter/modules/configuration/config/extensions/entity/PersonDummy_Ext.eti (entidad existente)
- PolicyCenter/modules/configuration/config/extensions/entity/CompanyDummy_Ext.eti (entidad existente)

**Validado por:** esteban.colorado | **Fecha:** 2025-12-22 | **Enfoque:** B - Exploratorio con consideraciones técnicas específicas del flujo existente

---

## Metadata

**Autor:** esteban.colorado (PO)  
**Fecha:** 2025-12-18  
**Historias relacionadas:** #915240, #830317  
**Modo de creación:** Importar historia existente (validada y mejorada)

---

## Métricas de redacción de la historia de usuario con el PO 

**Tiempo con Método Ceiba:** 12 minutos  
**Tiempo estimado tradicional:** 30 minutos  
**Optimización:** 60%

---
